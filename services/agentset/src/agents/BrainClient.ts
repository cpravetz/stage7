import { v4 as uuidv4 } from 'uuid';
import { PluginOutput, PluginParameterType, InputValue, LLMConversationType, ActionVerbTask } from '@cktmcs/shared';
import { AgentStatus } from '../utils/agentStatus';

/**
 * Interface for the agent context needed by BrainClient
 */
export interface BrainAgentContext {
    id: string;
    status: AgentStatus;
    brainUrl: string;
    missionContext: string;
    conversation: Array<{ role: string, content: string }>;
    authenticatedApi: any;
}

/**
 * Handles all interactions with the Brain service for reasoning and generation
 */
export class BrainClient {
    private agent: BrainAgentContext;

    constructor(agent: BrainAgentContext) {
        this.agent = agent;
    }

    /**
     * Get MIME type from conversation type
     */
    public getMimeTypeFromConversationType(conversationType: LLMConversationType): string {
        switch (conversationType) {
            case LLMConversationType.TextToText:
                return 'text/plain';
            case LLMConversationType.TextToCode:
                return 'application/json';
            case LLMConversationType.TextToImage:
                return 'image/png';
            case LLMConversationType.TextToAudio:
                return 'audio/mpeg';
            case LLMConversationType.TextToVideo:
                return 'video/mp4';
            default:
                return 'text/plain';
        }
    }

    /**
     * Truncate large strings for logging
     */
    private truncateLargeStrings(obj: any, maxLength: number = 500): any {
        if (obj === null || typeof obj !== 'object') {
            return obj;
        }
        if (Array.isArray(obj)) {
            return obj.map(item => this.truncateLargeStrings(item, maxLength));
        }
        const newObj: { [key: string]: any } = {};
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                const value = obj[key];
                if (typeof value === 'string' && value.length > maxLength) {
                    newObj[key] = `[Truncated string, length: ${value.length}]`;
                } else if (typeof value === 'object') {
                    newObj[key] = this.truncateLargeStrings(value, maxLength);
                } else {
                    newObj[key] = value;
                }
            }
        }
        return newObj;
    }

    /**
     * Use Brain service for reasoning (THINK) or generation (GENERATE)
     */
    public async useBrainForReasoning(inputs: Map<string, InputValue>, actionVerb: string): Promise<PluginOutput[]> {
        if (this.agent.status !== AgentStatus.RUNNING) {
            console.log(`Agent ${this.agent.id} is not RUNNING, aborting useBrainForReasoning.`);
            return [{
                success: false,
                name: 'error',
                resultType: PluginParameterType.ERROR,
                resultDescription: 'Agent not running',
                result: null,
                error: 'Agent is not in RUNNING state.'
            }];
        }

        let brainEndpoint: string;
        let brainRequestBody: any;
        let outputName: string;
        let outputDescription: string;

        // Enrich prompt for GENERATE and THINK
        let enrichedPrompt = '';
        const goal = inputs.get('goal')?.value;
        const context = this.agent.missionContext || inputs.get('context')?.value;
        const constraints = inputs.get('constraints')?.value;
        const userPrompt = inputs.get('prompt')?.value;
        const outputFormat = actionVerb === 'GENERATE' ? 'Return a concise answer in plain text.' : 'List your reasoning steps before the answer.';

        enrichedPrompt += `You are an autonomous agent.`;
        if (goal) enrichedPrompt += `\nGoal: ${goal}`;
        if (context) enrichedPrompt += `\nContext: ${context}`;
        if (constraints) enrichedPrompt += `\nConstraints: ${constraints}`;
        if (userPrompt) enrichedPrompt += `\nTask: ${userPrompt}`;
        enrichedPrompt += `\nInstructions: ${outputFormat}`;

        if (actionVerb === 'GENERATE') {
            brainEndpoint = 'generate';
            outputName = 'generated_content';
            outputDescription = 'Content generated by LLM service.';

            const modelName = inputs.get('modelName')?.value;
            const optimization = inputs.get('optimization')?.value;
            const file = inputs.get('file')?.value;
            const audio = inputs.get('audio')?.value;
            const video = inputs.get('video')?.value;
            const image = inputs.get('image')?.value;
            const conversationType = inputs.get('conversationType')?.value as LLMConversationType || LLMConversationType.TextToText;

            brainRequestBody = {
                type: conversationType,
                prompt: enrichedPrompt,
                modelName: modelName,
                optimization: optimization,
                file: file,
                audio: audio,
                video: video,
                image: image,
                trace_id: this.agent.id,
                contentType: this.getMimeTypeFromConversationType(conversationType),
            };
        } else {
            // THINK logic
            brainEndpoint = 'chat';
            outputName = 'answer';
            outputDescription = `Brain reasoning output (${inputs.get('conversationType')?.value || LLMConversationType.TextToText})`;

            const prompt = enrichedPrompt;
            const optimization = (inputs.get('optimization')?.value as string) || 'accuracy';
            const conversationType = (inputs.get('conversationType')?.value as LLMConversationType) || LLMConversationType.TextToText;

            const validOptimizations = ['cost', 'accuracy', 'creativity', 'speed', 'continuity'];
            const validConversationTypes = [
                LLMConversationType.TextToText,
                LLMConversationType.TextToImage,
                LLMConversationType.TextToAudio,
                LLMConversationType.TextToVideo,
                LLMConversationType.TextToCode
            ];

            if (!prompt) {
                return [{
                    success: false,
                    name: 'error',
                    resultType: PluginParameterType.ERROR,
                    resultDescription: 'Error in useBrainForReasoning',
                    result: null,
                    error: 'Prompt is required for THINK plugin'
                }];
            }
            if (!validOptimizations.includes(optimization)) {
                return [{
                    success: false,
                    name: 'error',
                    resultType: PluginParameterType.ERROR,
                    resultDescription: 'Error in useBrainForReasoning',
                    result: null,
                    error: `Invalid optimization: ${optimization}. Must be one of ${validOptimizations.join(', ')}`
                }];
            }
            if (!validConversationTypes.includes(conversationType)) {
                return [{
                    success: false,
                    name: 'error',
                    resultType: PluginParameterType.ERROR,
                    resultDescription: 'Error in useBrainForReasoning',
                    result: null,
                    error: `Invalid ConversationType: ${conversationType}. Must be one of ${validConversationTypes.join(', ')}`
                }];
            }

            brainRequestBody = {
                exchanges: [...this.agent.conversation, { role: 'user', content: prompt }],
                optimization: optimization,
                conversationType: conversationType,
                responseType: 'text'
            };
        }

        console.log(`[Agent ${this.agent.id} ${actionVerb}] useBrainForReasoning: Sending request to Brain /${brainEndpoint}`);

        try {
            const response = await this.agent.authenticatedApi.post(`${this.agent.brainUrl}/${brainEndpoint}`, brainRequestBody);
            const confidence = response.data.confidence || 1.0;
            const confidenceThreshold = (inputs.get('confidenceThreshold')?.value as number) || 0.75;

            // High-confidence path: Return the result directly
            if (confidence >= confidenceThreshold) {
                const brainResponse = response.data.response;
                const mimeType = response.data.mimeType || 'text/plain';

                let resultType: PluginParameterType;
                let parsedResult: any = brainResponse;

                if (actionVerb === 'THINK' && (inputs.get('conversationType')?.value as LLMConversationType) === LLMConversationType.TextToCode && mimeType === 'application/json') {
                    try {
                        parsedResult = typeof brainResponse === 'string' ? JSON.parse(brainResponse) : brainResponse;
                        resultType = PluginParameterType.PLAN;
                        console.log(`[Agent ${this.agent.id}] Parsed brainResponse as JSON for plan.`);
                    } catch (e) {
                        console.warn(`[Agent ${this.agent.id}] Failed to parse brainResponse as JSON, treating as string. Error:`, e instanceof Error ? e.message : e);
                        resultType = PluginParameterType.STRING;
                    }
                } else {
                    resultType = PluginParameterType.STRING;
                }

                // Defensive extraction for STRING results
                if (resultType === PluginParameterType.STRING) {
                    parsedResult = this.extractStringResult(parsedResult, response.data);
                }

                if (!parsedResult || (typeof parsedResult === 'string' && parsedResult.trim() === '')) {
                    console.warn(`[Agent ${this.agent.id}] WARNING: Brain returned an empty or missing result for actionVerb=${actionVerb}. Response payload:`, JSON.stringify(this.truncateLargeStrings(response.data || {}), null, 2));
                }

                return [{
                    success: true,
                    name: outputName,
                    resultType: resultType,
                    result: parsedResult,
                    resultDescription: outputDescription,
                    mimeType: mimeType
                }];
            }

            // Low-confidence path: Create a verification and continuation plan
            return this.createRecoveryPlan(response.data.response, confidence);

        } catch (error) {
            console.error('Error using Brain for reasoning:', error instanceof Error ? error.message : error);
            return [{
                success: false,
                name: 'error',
                resultType: PluginParameterType.ERROR,
                resultDescription: 'Error in useBrainForReasoning',
                result: null,
                error: error instanceof Error ? error.message : 'Unknown error occurred'
            }];
        }
    }

    /**
     * Extract string result from various response formats
     */
    private extractStringResult(parsedResult: any, responseData: any): string {
        try {
            if (parsedResult === undefined || parsedResult === null) {
                const candidate = responseData?.result || responseData?.text || responseData?.output || responseData?.generated || responseData?.response || responseData?.choices;
                if (candidate !== undefined && candidate !== null) {
                    return typeof candidate === 'string' ? candidate : (Array.isArray(candidate) ? JSON.stringify(candidate) : JSON.stringify(candidate));
                }
                return '';
            } else if (typeof parsedResult === 'object') {
                const fallback = parsedResult.result || parsedResult.text || (parsedResult.choices && parsedResult.choices[0] && (parsedResult.choices[0].text || parsedResult.choices[0].message)) || parsedResult.generated || parsedResult.output;
                if (fallback !== undefined && fallback !== null) {
                    return typeof fallback === 'string' ? fallback : JSON.stringify(fallback);
                }
                return JSON.stringify(parsedResult);
            }
            return String(parsedResult);
        } catch (e) {
            console.warn(`[Agent ${this.agent.id}] Error coercing brainResponse to string result:`, e instanceof Error ? e.message : e);
            return '';
        }
    }

    /**
     * Create a recovery plan for low-confidence results
     */
    private createRecoveryPlan(brainResponse: string, confidence: number): PluginOutput[] {
        console.log(`[Agent ${this.agent.id}] Low confidence (${confidence.toFixed(2)}), creating recovery plan.`);

        const verificationTask: ActionVerbTask = {
            id: uuidv4(),
            actionVerb: 'THINK',
            description: `Verify the following information which was returned with low confidence: "${brainResponse}"`,
            inputs: {
                prompt: {
                    value: `Verify the following fact: "${brainResponse}". Provide the verified fact and indicate if it is correct.`
                }
            },
            outputs: new Map<string, PluginParameterType>([
                ['verified_fact', PluginParameterType.STRING],
                ['is_correct', PluginParameterType.BOOLEAN]
            ]),
            recommendedRole: 'critic'
        };

        const continuationTask: ActionVerbTask = {
            id: uuidv4(),
            actionVerb: 'THINK',
            description: `Re-evaluating the original prompt with a verified fact.`,
            inputs: {
                prompt: {
                    value: `Re-evaluating the original prompt with a verified fact.`
                }
            },
            outputs: new Map<string, PluginParameterType>([
                ['final_answer', PluginParameterType.STRING]
            ])
        };

        return [{
            success: true,
            name: 'recovery_plan',
            resultType: PluginParameterType.PLAN,
            result: [verificationTask, continuationTask],
            resultDescription: `Generated a 2-step recovery plan due to low confidence score.`,
        }];
    }
}
